<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Symulator A1</title>
  <!-- Tone.js z CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
  <!-- dat.GUI z CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      margin: 0; 
      padding: 0; 
    }
    /* Lewa kolumna: panel kontrolny */
    #leftContainer {
      width: 50%;
      float: left;
      padding: 20px;
      box-sizing: border-box;
    }
    /* Prawa kolumna: wizualizacja analizatora */
    #rightContainer {
      width: 50%;
      float: left;
      padding: 20px;
      box-sizing: border-box;
    }
    canvas {
      background: #222;
      display: block;
      width: 100%;
      height: 100%;
    }
    /* Powiększenie czcionki w panelu dat.GUI */
    .dg.main {
      font-size: 150%;
    }
    h1 {
      font-size: 2em;
    }
    button {
      font-size: 1.5em;
      padding: 10px 20px;
      margin: 10px 5px;
    }
  </style>
</head>
<body>
  <!-- Lewa kolumna z tytułem, przyciskami i panelem kontrolnym -->
  <div id="leftContainer">
    <h1>Symulator A1</h1>
    <p>Użyj poniższych przycisków oraz panelu kontrolnego do sterowania dźwiękiem.</p>
    <button id="startButton">Uruchom Audio</button>
    <button id="triggerNote">Zagraj dźwięk</button>
    <button id="toggleNoise">Włącz/Wyłącz Szum</button>
  </div>
  <!-- Prawa kolumna z analizatorem -->
  <div id="rightContainer">
    <canvas id="analyserCanvas" width="600" height="400"></canvas>
  </div>
  
  <script>
    // Aktywacja kontekstu audio na żądanie użytkownika
    document.getElementById("startButton").addEventListener("click", async function(){
      await Tone.start();
      console.log("Audio Context uruchomiony");
    });

    // Utworzenie finalnego miksu – wszystkie źródła będą do niego kierowane
    const finalMix = new Tone.Gain(1);
    // Utworzenie analizatora wyświetlającego waveform
    const analyser = new Tone.Analyser("waveform", 1024);
    // Łańcuch: finalMix -> analyser -> wyjście
    finalMix.chain(analyser, Tone.Destination);

    // --- Główna ścieżka dźwiękowa (syntezator i efekty) ---
    const synth = new Tone.Synth({
      oscillator: {
        type: "sine",
        detune: 0,
        phase: 0,
        partials: []
      },
      envelope: {
        attack: 0.1,
        decay: 0.2,
        sustain: 0.5,
        release: 1,
        attackCurve: "linear",
        decayCurve: "linear",
        releaseCurve: "linear"
      }
    });

    const filter = new Tone.Filter({
      type: "lowpass",
      frequency: 1000,
      Q: 1,
      rolloff: -12
    });

    const delay = new Tone.FeedbackDelay({
      delayTime: 0.25,
      feedback: 0.3,
      wet: 0.5
    });
    const reverb = new Tone.Reverb({
      decay: 2,
      preDelay: 0.01,
      wet: 0.5
    });
    const chorus = new Tone.Chorus({
      frequency: 1.5,
      delayTime: 3.5,
      depth: 0.7,
      feedback: 0.2,
      wet: 0.5
    }).start();
    const distortion = new Tone.Distortion({
      distortion: 0.4,
      oversample: "4x",
      wet: 0.5
    });

    const volume = new Tone.Volume(-12);
    const panner = new Tone.Panner(0);

    // Łańcuch efektów syntezatora: synth -> filter -> delay -> reverb -> chorus -> distortion -> volume -> panner -> finalMix
    synth.chain(filter, delay, reverb, chorus, distortion, volume, panner, finalMix);

    // --- Szumy oraz dźwięki binauralne ---
    const noise = new Tone.Noise("white").start();
    const noiseVolume = new Tone.Volume(-12);
    const binauralPanner = new Tone.Panner3D({
      positionX: 0,
      positionY: 0,
      positionZ: -1
    });
    // Łańcuch szumu: noise -> noiseVolume -> binauralPanner -> finalMix
    noise.chain(noiseVolume, binauralPanner, finalMix);

    // Przycisk do przełączania szumu
    let noiseActive = true;
    document.getElementById("toggleNoise").addEventListener("click", function(){
      if (noiseActive) {
        noise.stop();
        noiseActive = false;
        console.log("Szum wyłączony");
      } else {
        noise.start();
        noiseActive = true;
        console.log("Szum włączony");
      }
    });

    // --- Nowe źródła dźwięku ---

    // Tone.Player – odtwarzacz audio
    const player = new Tone.Player({
      url: "https://tonejs.github.io/audio/berklee/groove.mp3",
      autostart: false
    }).connect(finalMix);

    // Tone.Sampler – sampler instrumentu (przykładowe próbki)
    const sampler = new Tone.Sampler({
      urls: {
        "C4": "C4.mp3",
        "D#4": "Ds4.mp3",
        "F#4": "Fs4.mp3"
      },
      baseUrl: "https://tonejs.github.io/audio/salamander/"
    }).connect(finalMix);

    // Alternatywne syntezatory – wybór spośród kilku typów
    let altSynth = null;  // przechowuje aktualnie wybrany alternatywny syntezator

    // Tone.UserMedia – przechwytywanie dźwięku z mikrofonu
    let mic, micActive = false;

    // --- Panel kontrolny dat.GUI ---
    const gui = new dat.GUI({ width: 400 });
    // Przeniesienie panelu do lewej kolumny
    document.getElementById("leftContainer").appendChild(gui.domElement);

    // 1. Oscylator
    const oscFolder = gui.addFolder("Oscylator");
    const oscSettings = {
      type: "sine",
      detune: 0,
      phase: 0,
      partials: 0
    };
    oscFolder.add(oscSettings, "type", ["sine", "square", "triangle", "sawtooth"]).onChange(val => {
      synth.oscillator.type = val;
    });
    oscFolder.add(oscSettings, "detune", -1200, 1200).onChange(val => {
      synth.oscillator.detune = val;
    });
    oscFolder.add(oscSettings, "phase", 0, 360).onChange(val => {
      synth.oscillator.phase = val;
    });
    oscFolder.add(oscSettings, "partials", 0, 10, 1).onChange(val => {
      if(val == 0) {
        synth.oscillator.partials = [];
      } else {
        const arr = [];
        for(let i = 1; i <= val; i++){
          arr.push(i);
        }
        synth.oscillator.partials = arr;
      }
    });
    oscFolder.open();

    // 2. Obwiednia
    const envFolder = gui.addFolder("Obwiednia");
    const envSettings = {
      attack: 0.1,
      decay: 0.2,
      sustain: 0.5,
      release: 1,
      attackCurve: "linear",
      decayCurve: "linear",
      releaseCurve: "linear"
    };
    envFolder.add(envSettings, "attack", 0, 2).onChange(val => {
      synth.envelope.attack = val;
    });
    envFolder.add(envSettings, "decay", 0, 2).onChange(val => {
      synth.envelope.decay = val;
    });
    envFolder.add(envSettings, "sustain", 0, 1).onChange(val => {
      synth.envelope.sustain = val;
    });
    envFolder.add(envSettings, "release", 0, 5).onChange(val => {
      synth.envelope.release = val;
    });
    envFolder.add(envSettings, "attackCurve", ["linear", "exponential"]).onChange(val => {
      synth.envelope.attackCurve = val;
    });
    envFolder.add(envSettings, "decayCurve", ["linear", "exponential"]).onChange(val => {
      synth.envelope.decayCurve = val;
    });
    envFolder.add(envSettings, "releaseCurve", ["linear", "exponential"]).onChange(val => {
      synth.envelope.releaseCurve = val;
    });
    envFolder.open();

    // 3. Filtr
    const filterFolder = gui.addFolder("Filtr");
    const filterSettings = {
      type: "lowpass",
      frequency: 1000,
      Q: 1,
      gain: 0,
      rolloff: -12
    };
    filterFolder.add(filterSettings, "type", ["lowpass", "highpass", "bandpass", "notch"]).onChange(val => {
      filter.type = val;
    });
    filterFolder.add(filterSettings, "frequency", 20, 20000).onChange(val => {
      filter.frequency.value = val;
    });
    filterFolder.add(filterSettings, "Q", 0.1, 20).onChange(val => {
      filter.Q.value = val;
    });
    filterFolder.add(filterSettings, "gain", -40, 40).onChange(val => {
      filter.gain = val;
    });
    filterFolder.add(filterSettings, "rolloff", [-12, -24]).onChange(val => {
      filter.rolloff = val;
    });
    filterFolder.open();

    // 4. Efekty
    const effectsFolder = gui.addFolder("Efekty");
    const delayFolder = effectsFolder.addFolder("Delay");
    const delaySettings = {
      delayTime: 0.25,
      feedback: 0.3,
      wet: 0.5
    };
    delayFolder.add(delaySettings, "delayTime", 0, 1).onChange(val => {
      delay.delayTime.value = val;
    });
    delayFolder.add(delaySettings, "feedback", 0, 1).onChange(val => {
      delay.feedback.value = val;
    });
    delayFolder.add(delaySettings, "wet", 0, 1).onChange(val => {
      delay.wet.value = val;
    });
    delayFolder.open();

    const reverbFolder = effectsFolder.addFolder("Reverb");
    const reverbSettings = {
      decay: 2,
      preDelay: 0.01,
      wet: 0.5
    };
    reverbFolder.add(reverbSettings, "decay", 0, 10).onChange(val => {
      reverb.decay = val;
      reverb.generate();
    });
    reverbFolder.add(reverbSettings, "preDelay", 0, 1).onChange(val => {
      reverb.preDelay = val;
    });
    reverbFolder.add(reverbSettings, "wet", 0, 1).onChange(val => {
      reverb.wet.value = val;
    });
    reverbFolder.open();

    const chorusFolder = effectsFolder.addFolder("Chorus/Flanger/Phaser");
    const chorusSettings = {
      frequency: 1.5,
      delayTime: 3.5,
      depth: 0.7,
      feedback: 0.2,
      wet: 0.5
    };
    chorusFolder.add(chorusSettings, "frequency", 0.1, 10).onChange(val => {
      chorus.frequency.value = val;
    });
    chorusFolder.add(chorusSettings, "delayTime", 0, 10).onChange(val => {
      chorus.delayTime = val;
    });
    chorusFolder.add(chorusSettings, "depth", 0, 1).onChange(val => {
      chorus.depth = val;
    });
    chorusFolder.add(chorusSettings, "feedback", 0, 1).onChange(val => {
      chorus.feedback = val;
    });
    chorusFolder.add(chorusSettings, "wet", 0, 1).onChange(val => {
      chorus.wet.value = val;
    });
    chorusFolder.open();

    const distortionFolder = effectsFolder.addFolder("Distortion");
    const distortionSettings = {
      distortion: 0.4,
      oversample: "4x",
      wet: 0.5
    };
    distortionFolder.add(distortionSettings, "distortion", 0, 1).onChange(val => {
      distortion.distortion = val;
    });
    distortionFolder.add(distortionSettings, "oversample", ["none", "2x", "4x"]).onChange(val => {
      distortion.oversample = val;
    });
    distortionFolder.add(distortionSettings, "wet", 0, 1).onChange(val => {
      distortion.wet.value = val;
    });
    distortionFolder.open();

    // 5. Głośność i Panoramowanie
    const outputFolder = gui.addFolder("Głośność i Panoramowanie");
    const outputSettings = {
      volume: -12,
      pan: 0
    };
    outputFolder.add(outputSettings, "volume", -60, 0).onChange(val => {
      volume.volume.value = val;
    });
    outputFolder.add(outputSettings, "pan", -1, 1).onChange(val => {
      panner.pan.value = val;
    });
    outputFolder.open();

    // 6. LFO
    const lfoFolder = gui.addFolder("LFO");
    const lfoSettings = {
      frequency: 0.5,
      min: 400,
      max: 1600,
      phase: 0,
      type: "sine"
    };
    lfoFolder.add(lfoSettings, "frequency", 0.1, 10).onChange(val => {
      lfo.frequency.value = val;
    });
    lfoFolder.add(lfoSettings, "min", 20, 1000).onChange(val => {
      lfo.min = val;
    });
    lfoFolder.add(lfoSettings, "max", 100, 5000).onChange(val => {
      lfo.max = val;
    });
    lfoFolder.add(lfoSettings, "phase", 0, 360).onChange(val => {
      lfo.phase = val;
    });
    lfoFolder.add(lfoSettings, "type", ["sine", "square", "triangle", "sawtooth"]).onChange(val => {
      lfo.type = val;
    });
    lfoFolder.open();

    // 7. Automatyzacja
    const automationFolder = gui.addFolder("Automatyzacja");
    const automationSettings = {
      rampAttack: function(){
        synth.oscillator.frequency.linearRampTo(800, 2);
      }
    };
    automationFolder.add(automationSettings, "rampAttack");
    automationFolder.open();

    // 8. Globalne Parametry Czasowe
    const timeFolder = gui.addFolder("Globalne Parametry Czasowe");
    const timeSettings = {
      tempo: 120,
      swing: 0,
      timeSignature: "4/4"
    };
    timeFolder.add(timeSettings, "tempo", 40, 300).onChange(val => {
      Tone.Transport.bpm.value = val;
    });
    timeFolder.add(timeSettings, "swing", 0, 1).onChange(val => {
      Tone.Transport.swing = val;
    });
    timeFolder.add(timeSettings, "timeSignature", ["2/4", "3/4", "4/4", "6/8"]).onChange(val => {
      Tone.Transport.timeSignature = val;
    });
    timeFolder.open();

    // --- Nowa sekcja: Źródła Dźwięku ---
    const sourcesFolder = gui.addFolder("Źródła Dźwięku");

    // Tone.Player – odtwarzacz audio
    const playerSettings = {
      play: function(){
        // Uruchomienie odtwarzania – player uruchamia się od początku
        player.start();
      }
    };
    sourcesFolder.add(playerSettings, "play").name("Odtwórz Player");

    // Tone.Sampler – sampler instrumentu
    const samplerSettings = {
      play: function(){
        sampler.triggerAttackRelease("C4", "8n");
      }
    };
    sourcesFolder.add(samplerSettings, "play").name("Odtwórz Sampler");

    // Alternatywne syntezatory – wybór spośród kilku typów
    let altSynth = null;
    const altSynthOptions = {
      type: "MembraneSynth",
      play: function(){
        if (altSynth) {
          altSynth.triggerAttackRelease("C2", "8n");
        }
      }
    };
    const altSynthFolder = sourcesFolder.addFolder("Alternatywne Syntezatory");
    altSynthFolder.add(altSynthOptions, "type", ["MembraneSynth", "MetalSynth", "PluckSynth", "AMSynth", "FMSynth", "MonoSynth"]).onChange(val => {
      // Jeśli istnieje poprzedni syntezator, usuń go
      if (altSynth) {
        altSynth.dispose();
        altSynth = null;
      }
      // Utwórz nowy syntezator na podstawie wybranego typu
      switch(val) {
        case "MembraneSynth":
          altSynth = new Tone.MembraneSynth().connect(finalMix);
          break;
        case "MetalSynth":
          altSynth = new Tone.MetalSynth().connect(finalMix);
          break;
        case "PluckSynth":
          altSynth = new Tone.PluckSynth().connect(finalMix);
          break;
        case "AMSynth":
          altSynth = new Tone.AMSynth().connect(finalMix);
          break;
        case "FMSynth":
          altSynth = new Tone.FMSynth().connect(finalMix);
          break;
        case "MonoSynth":
          altSynth = new Tone.MonoSynth().connect(finalMix);
          break;
      }
    });
    altSynthFolder.add(altSynthOptions, "play").name("Zagraj Alternatywny");

    // Tone.UserMedia – przechwytywanie dźwięku z mikrofonu
    const userMediaOptions = {
      toggleMic: async function(){
        if (!micActive) {
          mic = new Tone.UserMedia();
          try {
            await mic.open();
            mic.connect(finalMix);
            micActive = true;
            console.log("Mikrofon uruchomiony");
          } catch(e) {
            console.error("Nie udało się otworzyć mikrofonu:", e);
          }
        } else {
          mic.close();
          micActive = false;
          console.log("Mikrofon wyłączony");
        }
      }
    };
    sourcesFolder.add(userMediaOptions, "toggleMic").name("Uruchom/Wyłącz Mikrofona");

    // --- Wyzwolenie dźwięku głównego syntezatora ---
    document.getElementById("triggerNote").addEventListener("click", function(){
      synth.triggerAttackRelease("C4", "8n", Tone.now(), 0.7);
    });

    // --- LFO – przykład połączenia z częstotliwością filtra ---
    const lfo = new Tone.LFO({
      frequency: 0.5,
      min: 400,
      max: 1600,
      phase: 0,
      type: "sine"
    }).start();
    lfo.connect(filter.frequency);

    // --- Animacja analizatora – rysowanie waveform na canvas ---
    const canvas = document.getElementById("analyserCanvas");
    const canvasCtx = canvas.getContext("2d");
    function draw() {
      requestAnimationFrame(draw);
      const dataArray = analyser.getValue();
      canvasCtx.fillStyle = "#222";
      canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
      canvasCtx.lineWidth = 2;
      canvasCtx.strokeStyle = "#0f0";
      canvasCtx.beginPath();
      const sliceWidth = canvas.width / dataArray.length;
      let x = 0;
      for (let i = 0; i < dataArray.length; i++) {
        const v = (dataArray[i] + 1) / 2; // normalizacja z zakresu -1 do 1 na 0-1
        const y = v * canvas.height;
        if (i === 0) {
          canvasCtx.moveTo(x, y);
        } else {
          canvasCtx.lineTo(x, y);
        }
        x += sliceWidth;
      }
      canvasCtx.lineTo(canvas.width, canvas.height / 2);
      canvasCtx.stroke();
    }
    draw();
  </script>
</body>
</html>
