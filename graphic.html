<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Graphic Vita (Responsive Full Width)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background-color: black;
      width: 100%;
      height: 100%;
    }
    /* Kontener bez marginesów, wypełniający całą szerokość i wysokość, utrzymuje proporcje 1:1 */
    #container {
      position: relative;
      width: 100%;
      margin: 0;
      aspect-ratio: 1/1;
      background-color: black;
    }
    /* Canvas wypełnia cały kontener */
    #vitaCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="vitaCanvas"></canvas>
  </div>
  <script>
    let circlesData = null;

    // Odbiór danych przesłanych przez postMessage (np. z Wix)
    window.addEventListener("message", function(event) {
      if (event.data.action === "download") {
        downloadCanvas();
      } else if (event.data.circles) {
        circlesData = event.data.circles;
        drawGraphic();
      }
    }, false);

    function drawGraphic() {
      const canvas = document.getElementById("vitaCanvas");
      const ctx = canvas.getContext("2d");
      
      // Ustal aktualny rozmiar canvas na podstawie kontenera
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      
      // Wyczyść canvas i ustaw czarne tło
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Ustawienia stylu – biały tekst i linie
      ctx.fillStyle = "white";
      ctx.strokeStyle = "white";
      ctx.textAlign = "center";
      ctx.font = "16px Arial";
      
      if (!circlesData || circlesData.length === 0) {
        console.warn("Brak danych do rysowania!");
        return;
      }
      
      const gridRows = 3, gridCols = 3;
      const circleRadius = canvas.width / 12; // Promień proporcjonalny do szerokości
      const offsetX = canvas.width / (gridCols + 1);
      const offsetY = canvas.height / (gridRows + 1);
      
      // Dodajemy stały odstęp między sekcjami równy 50px
      const extraSpacing = 50;
      
      // Dla każdego wiersza (sekcji)
      for (let row = 0; row < gridRows; row++) {
        // Obliczamy y dla danego wiersza z dodatkowym odstępem
        let y = offsetY * (row + 1) + extraSpacing * row;
        
        // Pobieramy tekst sekcji z pierwszego koła w danym wierszu
        let sectionText = circlesData[row * gridCols].text;
        ctx.font = "bold 18px Arial";
        // Rysujemy etykietę sekcji wyśrodkowaną, powyżej koł
        ctx.fillText(sectionText, canvas.width / 2, y - circleRadius - 30);
        ctx.font = "16px Arial"; // Resetujemy font
        
        // Rysujemy koła w danym wierszu
        for (let col = 0; col < gridCols; col++) {
          let index = row * gridCols + col;
          let x = offsetX * (col + 1);
          
          // Rysujemy okrąg
          ctx.beginPath();
          ctx.arc(x, y, circleRadius, 0, 2 * Math.PI);
          ctx.stroke();
          
          // Pod kołem – wyświetlamy liczby pierwsze w formacie: 
          // liczba ujemna + "." + liczba dodatnia (bez spacji)
          let primesText = circlesData[index].primeNegative + "." + circlesData[index].primePositive;
          ctx.fillText(primesText, x, y + circleRadius + 20);
        }
      }
    }

    function downloadCanvas() {
      const canvas = document.getElementById("vitaCanvas");
      const link = document.createElement("a");
      link.download = "graphic.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
    }

    // Fallback – jeśli po 2 sekundach nie otrzymamy danych, używamy przykładowych wartości
    setTimeout(() => {
      if (!circlesData || circlesData.length === 0) {
        console.warn("Brak danych - fallback");
        circlesData = [];
        // Przykładowe dane: sekcje H, D, C
        for (let i = 0; i < 3; i++) {
          circlesData.push({ text: "H", primePositive: 2, primeNegative: -3 });
        }
        for (let i = 0; i < 3; i++) {
          circlesData.push({ text: "D", primePositive: 2, primeNegative: -3 });
        }
        for (let i = 0; i < 3; i++) {
          circlesData.push({ text: "C", primePositive: 2, primeNegative: -3 });
        }
        drawGraphic();
      }
    }, 2000);

    // Przerysowujemy grafikę przy zmianie rozmiaru okna
    window.addEventListener('resize', function() {
      if (circlesData) {
        drawGraphic();
      }
    });
  </script>
</body>
</html>
